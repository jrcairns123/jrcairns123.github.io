<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="lib/d3.v5.min.js"></script>
<script type="text/javascript" src="lib/d3-tip.min.js"></script>
<style>
    body {
            font: 12px sans-serif;
        }
    .d3-tip {
            background: black;
            color: white;
            padding: 12px;
            border-radius: 2px;
        }

/* add style stuff here like node size and link size*/

</style>
<head>
<title></title></head>
<body>

Select region: <select id="regionDropdown" name="region"></select><br>
Select minimum confidence for champion pair: <select id="confDropdown" name="conf"></select>


<div id="graph"></div>
<script>

var width = window.innerWidth, height = window.innerHeight;
var svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height);

// initiate tooltip for node
var node_tip = d3.tip()
                    .attr('class', 'd3-tip')
                    .attr("id", "node_tooltip")
                    .offset([-10,0]);

var link_tip = d3.tip()
                    .attr('class', 'd3-tip')
                    .attr("id", "link_tooltip")
                    .offset([-10,0]);

var region_list = document.getElementById("regionDropdown");
var conf_list = document.getElementById("confDropdown");

// region dropdown
var regionDropdown_dict = {
  0: ["All Regions","all"],
  1: ["EUN1 - Europe Nordic & East","eun1"],
  2: ["EUW1 - Europe West","euw1"],
  3: ["JP1 - Japan","jp1"],
  4: ["KR - Korea","kr"],
  5: ["NA1 - North America","na1"]
};

// confidence dropdown
var confDropdown_dict = {
  0: ["5%",5],
  1: ["8%",8],
  2: ["10%",10],
  3: ["12%",12],
  4: ["15%",15]
};

// length of region and confidence dropdown objects
var regionLength = Object.keys(regionDropdown_dict).length
var confLength = Object.keys(confDropdown_dict).length

for (i=0;i<regionLength;i++) {
    region_list.options[i] = new Option(regionDropdown_dict[i][0]);
};

for (i=0;i<confLength;i++) {
    conf_list.options[i] = new Option(confDropdown_dict[i][0]);
};

var select = document.querySelectorAll("select");

var region_index = 0;
var conf_index = 0;

// listener for region dropdown
select[0].addEventListener("change", function(event) {
    region_index = event.target.selectedIndex;
    console.log("region select "+region_index )
    draw_graph(region_index,conf_index)
})

// listener for confidence dropdown
select[1].addEventListener("change", function(event) {
    conf_index = event.target.selectedIndex;
    console.log("conf select "+conf_index )
    draw_graph(region_index,conf_index)
})

function draw_graph(region_index,conf_index) {

    var file = regionDropdown_dict[region_index][1];

    Promise.all([
                d3.dsv(",", "data/edges_"+file+"_0.1_5.csv", function(d) {
                return {
                    source: d.source,
                    target: d.target,
                    conf: +parseFloat(d["conf"]),
                    win_rate: +parseFloat(d['win_rate'])
                }
                }), 
                d3.dsv(",", "data/nodes_"+file+"_0.1_5.csv", function(d) {
                return {
                    champion: d.champion,
                    popularity: +parseFloat(d['popularity'])
                }
            })
            ]).then(
                function(data) {
                
                //wipe out previous chart
                svg.selectAll("*").remove();
                
                svg.append("text")
                        .text("Champion pair analysis for "+regionDropdown_dict[region_index][0]+", "+confDropdown_dict[conf_index][0]+" confidence")
                        .attr("x",5)
                        .attr("y",20)

                links = data[0]
                console.log("# of edges before filter: "+links.length)
                links = links.filter(function(d) {
                    return d['conf'] >= confDropdown_dict[conf_index][1]
                })
                console.log("# of edges after filter: "+links.length)

                nodes = data[1]
                console.log("# of nodes before filter: "+nodes.length)
                champion_set = new Set();
                for (i=0;i<links.length;i++) {
                    champion_set.add(links[i]['source']);
                    champion_set.add(links[i]['target'])
                }
                nodes = nodes.filter(function(d) {
                    return champion_set.has(d['champion'])
                })
                console.log("# of nodes after filter: "+nodes.length)
                // at this point the links and nodes are loaded

                // define some settings here, like when to change colors, opacity ranges etc.
                var winrate_range = [d3.min(links, d => d.win_rate), d3.max(links, d => d.win_rate)];
                var popularity_range = [d3.min(nodes, d => d.popularity), d3.max(nodes, d => d.popularity)]
                var conf_range = [d3.min(links, d => d.conf), d3.max(links, d => d.conf)]
                

                // define linear scales for opacity, etc
                var popularity_scale = d3.scaleLinear().domain(popularity_range).range([0.2,1]); // for node opacity
                var popularity_scale2 = d3.scaleLinear().domain(popularity_range).range([10,20]); // for node radius
                var conf_scale = d3.scaleQuantize().domain(conf_range).range(["6,3", "12,3", "18,3", "24,3"]); // for edge stroke dasharray
                var conf_scale2 = d3.scaleLinear().domain(conf_range).range([4,12]); // for edge stroke width

                // define diverging color scale for edges; red-yellow-green by win rate
                var winrate_scale = d3.scaleDiverging(d3.interpolateRdYlGn) // for edge stroke (color)
                                    .domain([winrate_range[0],0.5,winrate_range[1]]) // centered around 0.5, 50%
                                    .clamp(true); // clamp output color to maximum output of interpolator (i.e. red or green)

                // define the force directed graph
                var force = d3.forceSimulation()
                .nodes(d3.values(nodes))
                .force("link", d3.forceLink(links).id(function(d) {return d.champion}).distance(100))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force("x", d3.forceX())
                .force("y", d3.forceY())
                .force("charge", d3.forceManyBody().strength(-250))
                .alphaTarget(1)
                .on("tick", tick);
                
                svg.call(link_tip)
                link_tip.html(function(d) {
 
                return d.source.champion + " ==> "+ d.target.champion +"<br>" + 
                        "Confidence: " + d.conf.toFixed(1) + "%<br>" +
                        "Win Rate " + (d.win_rate*100).toFixed(1) + "%";
                });
                

                // draw the links, color depends on winrate ("scale" defined above) and opacity on conf
                var path = svg.append("g")
                    .selectAll("path")
                    .data(links)
                    .enter()
                    .append("path")
                    .attr("stroke-width", function(d) {return conf_scale2(d.conf)})
                    .attr("stroke", function(d) {return winrate_scale(d.win_rate)})
                    .attr("fill", "none")
                    .on('mouseover', link_tip.show)
                    .on('mouseout',link_tip.hide);


                svg.call(node_tip)
                node_tip.html(function(d) {

                return "Champion: " + d.champion + "<br>" + 
                        "Popularity: " + (d.popularity*100).toFixed(1) + "%";
                });

                var node = svg.selectAll(".node")
                    .data(force.nodes())
                    .enter().append("g")
                    .attr("class", "node")
                    .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))
                    .on('dblclick', function(d) {
                        d.fx = null
                        d.fy = null
                        d3.select(this)
                        .attr("fixed", "false")
                    })
                    .on('mouseover', node_tip.show)
                    .on('mouseout',node_tip.hide);
                
                // draw the node, opacity depends on popularity
                node.append("circle")
                    .attr("id", function(d){
                    return (d.champion);
                    })
                    .attr("r", function(d){return popularity_scale2(d.popularity)})
                    .style("fill", "black")
                    .attr("opacity", function(d){return popularity_scale(d.popularity)});


                // add champion name around node
                node.append("text")
                    .text(function(d){
                    return (d.champion);
                    })
                    .attr("transform", "translate(8,-15)")
                    .style("font-weight", "bold");
    
    
                // add the curvy lines
                function tick() {
                    path.attr("d", function(d) {
                        var dx = (d.target.x - d.source.x), 
                            dy = (d.target.y - d.source.y), 
                            dr = Math.sqrt(dx * dx + dy * dy);
                        return "M" +
                            d.source.x + "," +
                            d.source.y + "A" +
                            dr + "," + dr + " 0 0,1 " +
                            d.target.x + "," +
                            d.target.y;
                    });

                    node.attr("transform", function(d) {
                        return "translate(" + d.x + "," + d.y + ")"; 
                    });
                };

                function dragstarted(d) {
                    if (!d3.event.active) force.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                };

                function dragged(d) {
                    d.fx = d3.event.x;
                    d.fy = d3.event.y;
                };

                function dragended(d) {
                    if (!d3.event.active) force.alphaTarget(0);
                    d.fixed = true
                    if (d.fixed == true) {
                        d.fx = d.x;
                        d.fy = d.y;
                    }
                    else {
                        d.fx = null;
                        d.fy = null;
                    }
                };


                            }).catch(function(error) {
                console.log(error)});

}

draw_graph(region_index,conf_index);

</script>
</body>
</html>
